[
["merging-satellite-and-point-sensor-data.html", "2 Merging Satellite and Point Sensor Data 2.1 Generate Rasters 2.2 Export to CSV", " 2 Merging Satellite and Point Sensor Data There’s a fundamental challenge in our project to merge AOD data and predictor variables because the data capture techniques are very different. The satellite-based AOD data is measured continuously across the surface of the earth on a 1km by 1km grid system. Meanwhile, sensor data is only captured locally at the sensor location. Therefore, a method to interpolate local sensor data to generate a continuous surface of data is required. An ‘Optimized’ IDW interpolation was used to estimate sensor values across a 1km by 1km grid system. This method takes into account the sensor locations and value for each variable to estimate values in grid cells without a sensor based on a linear interpolation of nearby sensor values. The specific number of sensors to take into account and the distance decay power function were optimized by minimizing the RMSE (Error). This method was adapted from an RSpatial Tutorial on IDW interpolation with pollution and weather data. To simplify implementation and replication, the entire workflow was coded in R and bundled into a packaged named sensor2raster. The next sections demonstrate how to apply this package to sensor data. # devtools::install_url(&#39;https://uchicago.box.com/shared/static/tp7z7rffapjfan6x7tq6ajxj01s9qefe.tar.gz&#39;) library(sensor2raster, quietly = TRUE) 2.1 Generate Rasters Creating raster surfaces is easy using the sensor2raster function. This function takes the raw output from the riem or aqsr packages and identifies the sensor locations and data values to interpolate. The underlying IDW interpolation is performed by the gstat package. The code chunk below demonstrates how to take ASOS weather data and convert it to a Raster format. The weather data variable is a data frame containing temperature data measured at airports in the Greater Chicago and Milwaukee Areas in 2018. We also pass the AOD.grid, a RasterLayer object representing the grid cells where we want to predict temperature. These grid cells correspond exactly to the pixels of satellite AOD data. temp.rasters = sensor2raster(sensor.data = weather.data, # Input the raw data.frame from riem data.type = &#39;ASOS&#39;, # Specify data type (&#39;ASOS&#39; or &#39;EPA&#39;) reference.grid = AOD.grid, # Grid to interpolate over subvariable = &#39;tmpf&#39;) # Column name of variable to interpolate 2.2 Export to CSV While Raster data is helpful for spatial data analysis and geovisualizations, it is sometimes helpful to store the interpolation in a non-spatial format. The grid2csv function allows you to convert Raster data to CSV either cell-by-cell, or by aggregating to a vector geometry. The exported data.frame is halfway between Long and Wide format due to the 3-dimensional nature of our data. The table below describes how these CSVs are structured in the cell-by-cell case. Var_Name Raster.Cell M1.2018 M2.2018 … M12.2018 Monthly_Temperature 1 23 25 … 20 Monthly_Temperature 2 23 25 … 20 … … … … … … Monthly_Temperature 100 10 15 … 11 The length of the table equals the number of cells in the RasterStack. Each cell is given a unique identifier stored in the Raster.Cell column. The Var_Name colums represent the variable of interest. When there are multiple variables, they are row binded together, giving a long table format. The rest of the columns represent the names given to the layers within each RasterStack. Im this case, each column represents a month and year combination. Additional time periods are appended column-wise to the table. The following table describes the outputted data frame from the monthly temperature Rasters generated earlier. temp.export = grid2csv(rasters = list(temp.rasters[[1]]), var.names = &#39;Monthly_Temperature&#39;) Var_Name Raster.Cell M1.2018 M2.2018 M3.2018 M4.2018 M5.2018 M6.2018 M7.2018 M8.2018 M9.2018 M10.2018 M11.2018 M12.2018 Monthly_Temperature 1 22.75343 24.89301 32.54753 36.13429 59.56493 64.5328 70.55568 70.15553 62.38351 48.01338 30.81887 29.27243 Monthly_Temperature 2 22.75343 24.89301 32.54753 36.13429 59.56493 64.5328 70.55568 70.15553 62.38351 48.01338 30.81887 29.27243 Monthly_Temperature 3 22.75343 24.89301 32.54753 36.13429 59.56493 64.5328 70.55568 70.15553 62.38351 48.01338 30.81887 29.27243 Monthly_Temperature 4 22.75343 24.89301 32.54753 36.13429 59.56493 64.5328 70.55568 70.15553 62.38351 48.01338 30.81887 29.27243 Monthly_Temperature 5 22.75343 24.89301 32.54753 36.13429 59.56493 64.5328 70.55568 70.15553 62.38351 48.01338 30.81887 29.27243 Monthly_Temperature 6 22.75343 24.89301 32.54753 36.13429 59.56493 64.5328 70.55568 70.15553 62.38351 48.01338 30.81887 29.27243 The format of the table changes slightly when subsetting using a vecor object. A new column sj_join appears in the table, representing a unique allowing the table to be joined back to the origin sf object if needed. When subsetting by point features, the Raster_Cell column describes the cell that overlapped with each point feature. When subsettting by line or polygon features, the Raster_Cell column describes the cell that overlapped with the centroid of each geometry. temp.export.sf = grid2csv(rasters = list(temp.rasters[[1]]), var.names = &#39;Monthly_Temperature&#39;, sf.obj = counties) Var_Name Raster_Cell sf_join M1.2018 M2.2018 Monthly_Temperature 4745 21 22.74704 24.89580 Monthly_Temperature 4970 3 23.00074 25.13390 Monthly_Temperature 11038 8 23.88734 26.08940 Monthly_Temperature 12957 20 23.22283 25.46473 Monthly_Temperature 15155 19 24.72884 26.94046 Monthly_Temperature 21000 4 24.81107 27.53006 The code chunk below demonstrates how to exploit the sf_join field to join the table data back to the spatial sf object. counties.join = counties %&gt;% tibble::rowid_to_column() %&gt;% dplyr::rename(sf_join = rowid) counties.join = grid2csv(rasters = list(temp.rasters[[1]]), var.names = &#39;Monthly_Temperature&#39;, sf.obj = counties.join) %&gt;% left_join(counties.join) %&gt;% st_as_sf() "]
]
